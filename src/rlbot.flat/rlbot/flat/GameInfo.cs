// <auto-generated>
//  automatically generated by the FlatBuffers compiler, do not modify
// </auto-generated>

namespace rlbot.flat
{

using global::System;
using global::FlatBuffers;

public struct GameInfo : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static GameInfo GetRootAsGameInfo(ByteBuffer _bb) { return GetRootAsGameInfo(_bb, new GameInfo()); }
  public static GameInfo GetRootAsGameInfo(ByteBuffer _bb, GameInfo obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p.bb_pos = _i; __p.bb = _bb; }
  public GameInfo __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public float SecondsElapsed { get { int o = __p.__offset(4); return o != 0 ? __p.bb.GetFloat(o + __p.bb_pos) : (float)0.0f; } }
  public float GameTimeRemaining { get { int o = __p.__offset(6); return o != 0 ? __p.bb.GetFloat(o + __p.bb_pos) : (float)0.0f; } }
  public bool IsOvertime { get { int o = __p.__offset(8); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }
  public bool IsUnlimitedTime { get { int o = __p.__offset(10); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }
  /// True when cars are allowed to move, and during the pause menu. False during replays.
  public bool IsRoundActive { get { int o = __p.__offset(12); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }
  /// True when the clock is paused due to kickoff, but false during kickoff countdown. In other words, it is true
  /// while cars can move during kickoff. Note that if both players sit still, game clock start and this will become false.
  public bool IsKickoffPause { get { int o = __p.__offset(14); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }
  /// Turns true after final replay, the moment the 'winner' screen appears. Remains true during next match
  /// countdown. Turns false again the moment the 'choose team' screen appears.
  public bool IsMatchEnded { get { int o = __p.__offset(16); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }
  public float WorldGravityZ { get { int o = __p.__offset(18); return o != 0 ? __p.bb.GetFloat(o + __p.bb_pos) : (float)0.0f; } }
  /// Game speed multiplier, 1.0 is regular game speed.
  public float GameSpeed { get { int o = __p.__offset(20); return o != 0 ? __p.bb.GetFloat(o + __p.bb_pos) : (float)0.0f; } }

  public static Offset<GameInfo> CreateGameInfo(FlatBufferBuilder builder,
      float secondsElapsed = 0.0f,
      float gameTimeRemaining = 0.0f,
      bool isOvertime = false,
      bool isUnlimitedTime = false,
      bool isRoundActive = false,
      bool isKickoffPause = false,
      bool isMatchEnded = false,
      float worldGravityZ = 0.0f,
      float gameSpeed = 0.0f) {
    builder.StartObject(9);
    GameInfo.AddGameSpeed(builder, gameSpeed);
    GameInfo.AddWorldGravityZ(builder, worldGravityZ);
    GameInfo.AddGameTimeRemaining(builder, gameTimeRemaining);
    GameInfo.AddSecondsElapsed(builder, secondsElapsed);
    GameInfo.AddIsMatchEnded(builder, isMatchEnded);
    GameInfo.AddIsKickoffPause(builder, isKickoffPause);
    GameInfo.AddIsRoundActive(builder, isRoundActive);
    GameInfo.AddIsUnlimitedTime(builder, isUnlimitedTime);
    GameInfo.AddIsOvertime(builder, isOvertime);
    return GameInfo.EndGameInfo(builder);
  }

  public static void StartGameInfo(FlatBufferBuilder builder) { builder.StartObject(9); }
  public static void AddSecondsElapsed(FlatBufferBuilder builder, float secondsElapsed) { builder.AddFloat(0, secondsElapsed, 0.0f); }
  public static void AddGameTimeRemaining(FlatBufferBuilder builder, float gameTimeRemaining) { builder.AddFloat(1, gameTimeRemaining, 0.0f); }
  public static void AddIsOvertime(FlatBufferBuilder builder, bool isOvertime) { builder.AddBool(2, isOvertime, false); }
  public static void AddIsUnlimitedTime(FlatBufferBuilder builder, bool isUnlimitedTime) { builder.AddBool(3, isUnlimitedTime, false); }
  public static void AddIsRoundActive(FlatBufferBuilder builder, bool isRoundActive) { builder.AddBool(4, isRoundActive, false); }
  public static void AddIsKickoffPause(FlatBufferBuilder builder, bool isKickoffPause) { builder.AddBool(5, isKickoffPause, false); }
  public static void AddIsMatchEnded(FlatBufferBuilder builder, bool isMatchEnded) { builder.AddBool(6, isMatchEnded, false); }
  public static void AddWorldGravityZ(FlatBufferBuilder builder, float worldGravityZ) { builder.AddFloat(7, worldGravityZ, 0.0f); }
  public static void AddGameSpeed(FlatBufferBuilder builder, float gameSpeed) { builder.AddFloat(8, gameSpeed, 0.0f); }
  public static Offset<GameInfo> EndGameInfo(FlatBufferBuilder builder) {
    int o = builder.EndObject();
    return new Offset<GameInfo>(o);
  }
};


}
